n= int(input())
k= int(input())
M=int(1e9)+3
dp= [[0]*(k+1) for _ in range(n)]
for i in range(1,n):
    dp[i][1]=1
for i in range(1,n):
    for a in range(1,k+1):
        if i-2>=0:
            dp[i][a]+=dp[i-2][a-1]
            dp[i][a]%=M
    for a in range(1,k+1):
        dp[i][a]+=dp[i-1][a]
        dp[i][a]%=M
        
#print(dp)
red= [[0]*(k+1) for _ in range(n)]
red[0][1]=1
for i in range(n-1):
    for a in range(1,k+1):
        if i-2>=0:
            red[i][a]+=red[i-2][a-1]
            red[i][a]%=M
    for a in range(1,k+1):
        red[i][a]+=red[i-1][a]
        red[i][a]%=M
#print(red)

ans=dp[n-1][k]+red[n-2][k]
ans%=M
print(ans)
'''
우선 색상환 dp[i-1][j]: idx 0~i-1색으로 이뤄진 원형판에 j개의 컬러를 서로 인접하지 않게 선택한 경우의 수를 담은 곳 이라고 정하'려고' 했어요.
그래서 머릿속으로 그럼을 12시를 원형판의 첫번째라하고 11시를 원형판의 마지막이라고 그렸어요.

1. 가짓수를 쌓아올리는 방법은 '11시색을 선택'해서 컬러 고르는 경우 만들거나(그럼 바로 전 색깔을 선택하지 않은, 
    i-2 원형판에서 j-1개 컬러 고른 경우의 수(dp[i-2][a-1]) 에 11시색 얹으면되니까 dp[i-2][a-1] 그대로 가져가면겠죠 10줄), 
2. 11시색(마지막 색)을 '빼고' 선택해서 경우를 만들거나(그럼 이경우엔  i원형판에서 j개 고른 경우의수는, i-1원형판에서 j개 고른 경우의수 그대로 가져오면 되겠죠 13줄)로 나눌 수 있겠죠

근데 11시색(마지막색)을 선택했을때가 문제가돼요. 11시색(마지막색), 12시색(첫번째색)을 둘다 선택하면 인접한 색을 택한게 되니까요. 
그래서 위에 설명한걸 계산할때는 12시색(첫번째색)을 무조건선택하지 '않고' 색을 골랐다고 놓았어요. 방법은 아래와 같아요.
dp[i][1]은 idx 0~i-1색으로 이뤄진 원형판에 1개의 컬러를 서로 인접하지 않게 선택한 경우의 수라고 놨잖아요?
dp[1][1]~dp[i-1][1]을 우선 1로 채웠어요. 한개 고른 색을 마지막색이라고 했을때의 경우의수인 1가지를 일단 채워논거에요.
근데 dp[0][1]만 0으로 놓았어요
idx 0색으로 1개 컬러 고르는 가짓수만 0으로 놓으면 첫번째 색을 고른 경우의수는 계산하지 않은 셈이 되니까요.

dp[i][j]: i개로 이뤄진 원형판에 j개의 컬러를선택할때 12시색(첫번째색)은 무조건 선택하지 '않은' 경우의 수



이제 12시색(첫번째색)을 무조건 '선택'했을때의 경우도 따로 구해줘야하니까 red 디피배열을 또 만들었어요
red[i][j]: i개로 이뤄진 원형판에 j개의 컬러를선택할때 12시색(첫번째색)은 무조건 '선택'한 경우의 수

12시색을 무조건 선택했으면 11시색 안고르면 되니까 dp range를 n까지가 아닌 n-1까지만 돌리면 돼요 19줄

이렇게 dp, red 둘다 돌려서 마지막에 두 경우의수 합해줬어요
'''